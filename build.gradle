import java.util.regex.Pattern

buildscript {
    ext {
        springBootVersion = '1.5.7.RELEASE+'
    }
    repositories {
        maven {
            url 'https://plugins.gradle.org/m2/'
        }
        mavenCentral()
        jcenter()

    }
    dependencies {
        classpath("org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}")
        classpath "org.jfrog.buildinfo:build-info-extractor-gradle:4.4.13"
        classpath "org.ajoberstar:grgit:1.7.2"
    }
}

apply plugin: 'base'
apply plugin: 'idea'

repositories {
    mavenCentral()
    jcenter()
}

subprojects {
    group = 'org.venuspj'
    version = '1.0.0'
    apply plugin: 'java'
    apply plugin: 'idea'
    apply plugin: 'jacoco'
    apply plugin: "findbugs"
    apply plugin: "maven"
    apply plugin: 'pmd'
    ext {
        //Library versions
        springBootVersion = '1.5.7.RELEASE'
        springSecurityOauth2Version = '2.1.0.RELEASE+'
        assertJVersion = '3.6.2'
        h2dbVersion = '1.4.193+'
        logbackVersion = '1.1.11'
        slf4jVersion = '1.7.25'
        junitVersion = "4.12"
        thymeleafExtrasVersion = '3.0.2.RELEASE+'
        thymeleafExtrasJava8timeVersion = '3.0.0.RELEASE+'
        springSessionVersion = '1.3.0.RELEASE+'
        findbugsAnnotationsVersion = '3.0.1'
        mySqlConnectorVersion = '5.1.44'
        myBatisSpringBootVersion = '1.3.1'
        mybatisTypehandlersJsr310Version = '1.0.2'
        // build paramaters
        defaultEncoding = 'UTF-8'
    }
    //buildDir = 'out'
    //tasks.withType(AbstractCompile)*.options*.encoding = defaultEncoding
    //tasks.withType(GroovyCompile)*.groovyOptions*.encoding = defaultEncoding
    idea.module.outputDir = compileJava.destinationDir
    idea.module.inheritOutputDirs = true

    sourceCompatibility = JavaVersion.VERSION_1_8
    targetCompatibility = JavaVersion.VERSION_1_8

    repositories {
        maven {
            url 'http://repo.opennms.org/maven2/'
        }
        jcenter()
    }

    gradle.projectsEvaluated {
        tasks.withType(JavaCompile) {
            options.compilerArgs << "-Xlint:unchecked" << "-Xlint:deprecation"
        }
    }

    tasks.withType(JavaCompile) {
        options.incremental = true
    }

    dependencies {
        compile group: 'com.google.code.findbugs', name: 'annotations', version: "${findbugsAnnotationsVersion}"
        testCompile group: 'org.assertj', name: 'assertj-core', version: "${assertJVersion}"
        testCompile(group: 'junit', name: 'junit', version: "${junitVersion}")
    }

    findbugs {
        // 失敗しても後続の処理を継続させる
        ignoreFailures = true
        sourceSets = [sourceSets.main]
        toolVersion = "3.0.1"
    }

    pmd {
        // 失敗しても後続の処理を継続させる
        ignoreFailures = true
        sourceSets = [sourceSets.main]
    }

    tasks.withType(Pmd) {
        reports {
            xml.enabled = true
        }
    }

// CPD（重複コードチェック処理）をCheckタスクに追加
    check.doLast {
        File outputDir = new File("$reportsDir/cpd/")
        outputDir.mkdirs()

        ant.taskdef(
                name: 'cpd',
                classname: 'net.sourceforge.pmd.cpd.CPDTask',
                classpath: configurations.pmd.asPath)

        ant.cpd(
                minimumTokenCount: '100',
                format: 'xml',
                encoding: defaultEncoding,
                outputFile: new File(outputDir, 'cpd.xml')
        ) {
            fileset(dir: "src/main/java") {
                include(name: '**/*.java')
                exclude(name: '**/*Mock*.java,**/*Example*.java')
            }
        }
    }

    test {
        // 失敗しても後続の処理を継続させる
        ignoreFailures = true
        reports {
            junitXml.enabled = true
        }
    }

    jacoco {
        toolVersion = '0.7.5.201505241946'
    }

    jacocoTestReport {
        reports {
            xml.enabled = true
        }

        // カバレッジレポートからテストクラスを除外
        afterEvaluate {
            classDirectories = files(classDirectories.files.collect {
                fileTree(dir: it, exclude: ['**/*Test.class', '**/*Mock.class', '**/*Example.class'])
            })
        }
    }

    task wrapper(type: Wrapper) {
        gradleVersion = '3.5.1'
    }

}

task wrapper(type: Wrapper) {
    gradleVersion = '3.5.1'
}

task incrementVersionCode {
    doLast {
        println(":incrementVersionCode - Incrementing Version Code...")
        def buildGradleFile = file("build.gradle")
        def patternVersionCode = Pattern.compile("versionCode (\\d+)")
        def buildGradleFileText = buildGradleFile.getText()
        def matcherVersionCode = patternVersionCode.matcher(buildGradleFileText)
        matcherVersionCode.find()
        def mVersionCode = Integer.parseInt(matcherVersionCode.group(1))
        def mNextVersionCode = mVersionCode + 1
        def manifestContent = matcherVersionCode.replaceAll("versionCode " + mNextVersionCode)
        println(":incrementVersionCode - current versionCode=" + mVersionCode);
        println(":incrementVersionCode - next versionCode=" + mNextVersionCode);
        buildGradleFile.write(manifestContent)
    }
}
